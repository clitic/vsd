/*
    REFERENCES
    ----------

    1. https://curl.se/docs/http-cookies.html

*/

#[cfg(feature = "capture")]
use chromiumoxide::cdp::browser_protocol::network::{
    Cookie as BrowserCookie, CookieParam, TimeSinceEpoch,
};

use chrono::{TimeZone, Utc};
use std::str;

#[derive(Clone, Debug)]
pub struct Cookies<'a>(pub Vec<Cookie<'a>>);

impl<'a> Cookies<'a> {
    pub fn parse(input: &'a [u8]) -> Result<Self, ParseError> {
        let mut cookies = Vec::new();
        let mut line_num = 0;
        let mut start = 0;

        while start < input.len() {
            line_num += 1;
            let end = input[start..]
                .iter()
                .position(|&b| b == b'\n')
                .map(|p| start + p)
                .unwrap_or(input.len());
            let mut line = &input[start..end];
            start = end + 1;
            if line.ends_with(b"\r") {
                line = &line[..line.len() - 1];
            }
            if line.is_empty() {
                continue;
            }

            let (http_only, effective) = match line {
                line if line.starts_with(b"#HttpOnly_") => (true, &line[10..]),
                line if line.starts_with(b"#") => continue,
                line => (false, line),
            };

            let parts = effective.split(|&b| b == b'\t').collect::<Vec<_>>();
            if parts.len() != 7 {
                return Err(ParseError::InvalidColumnParams(line_num, parts.len()));
            }

            cookies.push(Cookie {
                domain: str::from_utf8(parts[0])?,
                include_subdomains: match str::from_utf8(parts[1])? {
                    "TRUE" | "true" => true,
                    "FALSE" | "false" => false,
                    s => return Err(ParseError::InvalidBoolean(line_num, s.to_owned())),
                },
                path: str::from_utf8(parts[2])?,
                secure: match str::from_utf8(parts[3])? {
                    "TRUE" | "true" => true,
                    "FALSE" | "false" => false,
                    s => return Err(ParseError::InvalidBoolean(line_num, s.to_owned())),
                },
                expires: str::from_utf8(parts[4])?.parse::<i64>().map_err(|_| {
                    ParseError::InvalidInteger(
                        line_num,
                        str::from_utf8(parts[4]).unwrap().to_owned(),
                    )
                })?,
                name: str::from_utf8(parts[5])?,
                value: str::from_utf8(parts[6])?,
                http_only,
            });
        }

        Ok(Cookies(cookies))
    }

    pub fn to_netscape(&self) -> String {
        let mut out = "# Netscape HTTP Cookie File\n\
        # https://curl.se/docs/http-cookies.html\n\
        # This file was generated by vsd! Edit at your own risk.\n\n"
            .to_owned();
        for c in &self.0 {
            out.push_str(&c.to_netscape());
            out.push('\n');
        }
        out
    }
}

#[derive(Clone, Debug)]
pub struct Cookie<'a> {
    domain: &'a str,
    include_subdomains: bool,
    path: &'a str,
    secure: bool,
    expires: i64,
    name: &'a str,
    value: &'a str,
    http_only: bool,
}

impl<'a> Cookie<'a> {
    fn to_netscape(&self) -> String {
        format!(
            "{}\t{}\t{}\t{}\t{}\t{}\t{}",
            if self.http_only {
                &format!("#HttpOnly_{}", self.domain)
            } else {
                self.domain
            },
            if self.include_subdomains {
                "TRUE"
            } else {
                "FALSE"
            },
            self.path,
            if self.secure { "TRUE" } else { "FALSE" },
            self.expires,
            self.name,
            self.value
        )
    }

    pub fn to_header(&self) -> String {
        let mut h = format!("{}={}", self.name, self.value);
        if !self.domain.is_empty() {
            h.push_str(&format!("; Domain={}", self.domain));
        }
        if !self.path.is_empty() {
            h.push_str(&format!("; Path={}", self.path));
        }
        if self.expires > 0 {
            if let Some(dt) = Utc.timestamp_opt(self.expires, 0).single() {
                h.push_str(&format!(
                    "; Expires={}",
                    dt.format("%a, %d %b %Y %H:%M:%S GMT")
                ));
            }
        }
        if self.secure {
            h.push_str("; Secure");
        }
        if self.http_only {
            h.push_str("; HttpOnly");
        }
        h
    }

    pub fn url(&self) -> String {
        format!(
            "{}://{}{}",
            if self.secure { "https" } else { "http" },
            self.domain.strip_prefix('.').unwrap_or(self.domain),
            if self.path.starts_with('/') {
                self.path
            } else {
                "/"
            }
        )
    }
}

#[derive(Debug)]
pub enum ParseError {
    InvalidBoolean(usize, String),
    InvalidColumnParams(usize, usize),
    InvalidInteger(usize, String),
    Utf8Error(str::Utf8Error),
}

impl std::error::Error for ParseError {}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ParseError::InvalidBoolean(l, v) => write!(f, "Line {} bool: {}", l, v),
            ParseError::InvalidColumnParams(l, c) => write!(f, "Line {} cols: {}", l, c),
            ParseError::InvalidInteger(l, v) => write!(f, "Line {} int: {}", l, v),
            ParseError::Utf8Error(e) => write!(f, "UTF-8 error: {}", e),
        }
    }
}

impl From<str::Utf8Error> for ParseError {
    fn from(err: str::Utf8Error) -> Self {
        ParseError::Utf8Error(err)
    }
}

#[cfg(feature = "capture")]
impl<'a> From<&'a Vec<CookieParam>> for Cookies<'a> {
    fn from(value: &'a Vec<CookieParam>) -> Self {
        Cookies(
            value
                .iter()
                .map(|c| Cookie {
                    domain: c.domain.as_deref().unwrap_or(""),
                    include_subdomains: false,
                    path: c.path.as_deref().unwrap_or(""),
                    secure: c.secure.unwrap_or(false),
                    expires: c.expires.as_ref().map(|x| *x.inner() as i64).unwrap_or(0),
                    name: &c.name,
                    value: &c.value,
                    http_only: c.http_only.unwrap_or(false),
                })
                .collect(),
        )
    }
}

#[cfg(feature = "capture")]
impl<'a> From<&'a Vec<BrowserCookie>> for Cookies<'a> {
    fn from(value: &'a Vec<BrowserCookie>) -> Self {
        Cookies(
            value
                .iter()
                .map(|c| Cookie {
                    domain: &c.domain,
                    include_subdomains: false,
                    path: &c.path,
                    secure: c.secure,
                    expires: c.expires as i64,
                    name: &c.name,
                    value: &c.value,
                    http_only: c.http_only,
                })
                .collect(),
        )
    }
}

#[cfg(feature = "capture")]
impl<'a> Into<Vec<CookieParam>> for Cookies<'a> {
    fn into(self) -> Vec<CookieParam> {
        self.0
            .into_iter()
            .map(|c| CookieParam {
                name: c.name.to_owned(),
                value: c.value.to_owned(),
                url: Some(c.url()),
                domain: if c.domain.is_empty() {
                    None
                } else {
                    Some(c.domain.to_owned())
                },
                path: if c.path.is_empty() {
                    None
                } else {
                    Some(c.path.to_owned())
                },
                secure: Some(c.secure),
                http_only: Some(c.http_only),
                same_site: None,
                expires: Some(TimeSinceEpoch::new(c.expires as f64)),
                priority: None,
                same_party: None,
                source_scheme: None,
                source_port: None,
                partition_key: None,
            })
            .collect()
    }
}
